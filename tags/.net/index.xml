<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.net on Lee&#39;s Blog</title>
    <link>https://ev1si0n.github.io/tags/.net/</link>
    <description>Recent content in .net on Lee&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 23 Jun 2022 11:43:45 +0800</lastBuildDate><atom:link href="https://ev1si0n.github.io/tags/.net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>List.Foreach一点小九九</title>
      <link>https://ev1si0n.github.io/post/list.foreach%E4%B8%80%E7%82%B9%E5%B0%8F%E4%B9%9D%E4%B9%9D/</link>
      <pubDate>Thu, 23 Jun 2022 11:43:45 +0800</pubDate>
      
      <guid>https://ev1si0n.github.io/post/list.foreach%E4%B8%80%E7%82%B9%E5%B0%8F%E4%B9%9D%E4%B9%9D/</guid>
      <description>在排查界面查询慢时，查看日志，发现抛出了异常
var jianyan = i_ODS_JianYanSQYZList.Where(o =&amp;gt; o.JIUZHENYWID == yizhujl.BINGRENZYID &amp;amp;&amp;amp; o.YIZHUID == yizhujl.YIZHUID).FirstOrDefault(); 这里会提示未将对象引用到对象的实例，开始时候以为是LINQ表达式写的有问题，其实是i_ODS_JianYanSQYZList这个list里存在为null的数据。因此抛出异常。
resp.RespContent.JianYanBGList.ForEach(o =&amp;gt; { o.JianYanBGMXList = jianYanBGMXList.Where(p =&amp;gt; p.BAOGAODID == o.BAOGAOID).ToList(); o.JianYanSQD = jianYanSQDList.Where(p =&amp;gt; p.TIAOMA == o.TIAOMA &amp;amp;&amp;amp; req.ReqsContent.MPIList.Contains(p.MPI)).FirstOrDefault(); i_ODS_JianYanSQYZList.Add(o.JianYanSQD); });//此处这个LINQ表达式其实是有问题的 跟踪业务代码会发现i_ODS_JianYanSQYZList这个list，在add的时候，由于使用了Foreach，则会根据JianYanBGList数量去Add，此处就会出问题，将为null的数据添加到i_ODS_JianYanSQYZList中，然后引发后续的错误</description>
    </item>
    
    <item>
      <title>构造函数详解</title>
      <link>https://ev1si0n.github.io/post/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 20 Jun 2022 17:16:45 +0800</pubDate>
      
      <guid>https://ev1si0n.github.io/post/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>前两天，在复习.net相关基础的时候，恰巧看到了一片关于构造函数的文章，有很多平时没有注意到的地方。特记录下来。
一、构造函数的定义 ​ C#中构造函数是在创建给定类型的对象时执行的类方法。构造函数具有与类相同的名称，它通常初始化新对象的数据成员。不带参数的构造函数称为“默认构造函数”。 无论什么时候，只要使用new运算符实例化对象，并且不为 new 提供任何参数，就会调用默认构造函数。除非类是静态的，否则C#编译器将为无构造函数的类提供一个公共的默认构造函数，以便该类可以实例化。默认构造函数:public 类名(){}
构造函数可分为：实例构造函数，静态构造函数，私有构造函数（下面会详细介绍）
二、构造函数时的注意事项 ​ 构造函数没有返回值（void也不需要） 一个类中可以有多个构造函数，可根据其参数个数，参数顺序，参数类型的不同来区分它们，这称作构造函数的重载 构造函数的命名必须和类名相同 调用子类的构造函数时会先调用父类的无参构造函数 通常使用构造函数来进行类中字段的赋初值 构造函数不能直接被调用，必须通过关键字new在创建对象时自动调用 当一个类没有定义任何构造函数时，C#编译器会自动为其生成一个默认的隐式无参构造函数 如果一个类中定义了有参构造函数，实例化时需要调用无参构造函数，这时我们就必须定义一个显式无参数构造函数，否则运行会报错
三、构造函数与一般函数的区别 1.声明方式不同
构造函数： [访问修饰符] 类名(参数列表){函数主体}
public class1(int a) { } 一般函数： [访问修饰符] 返回类型 方法名(参数列表){函数主体}
public int class2(int a) { } 2.调用方式不同
构造函数：在类实例化时调用 一般函数：在类实例化后，必须手动调用
四、构造函数的作用 当需要给一个类中的字段进行初始化时，第一种：实例化后手动给属性赋值；第二种实例化时直接把参数放进去自动给属性赋值，显然第二种简单省事。下来我们一起看看两种方法：
第一种：
class Program { static void Main(string[] args) { Student stu = new Student(); stu.Id = 1807; stu.Name = &amp;#34;王麻子&amp;#34;; stu.Sex = &amp;#34;男&amp;#34;; stu.Score = 88.6; Console.</description>
    </item>
    
  </channel>
</rss>
